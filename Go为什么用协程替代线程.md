# Go为什么用协程替代线程?

Gorountine(协程)让并发编程变成简单。这个设计能让程序多通道地执行在一系列的线程上，当一个协程阻塞了，例如执行了一段系统阻塞命令。“运行时”系统runtime会自动地将其它的协程转移到，同处于一个系统态的线程的其他协程转移到另外一个可运行的线程中，这样这些协程就不会被阻塞。程序员是看不到这些细节实现的，这其实很关键。我们执行一个协程代价十分低。它的花销不超过一个堆栈的空间。

为了让堆栈更小，Go的运行在一个可扩容的（但有上限）的堆栈。一个新造的协程初始容量是几个kb，在一个堆栈中能够容纳的协程数量几乎够用了。如果不够用的时候，go的运行时会自动扩容堆栈，来提高容纳协程数量。每一个函数调用只花费3个低消耗的指令。

在同一个内存地址上创建成百上千个协程十分便捷，而如果使用线程，相同数量情况下，系统资源会很快被消耗干净。

```go
multiplex 多路的、多样的
overhead n 花销
mint adj 完美的、新造的
modest adj 适度的，谦虚的
instruction n 指令
```




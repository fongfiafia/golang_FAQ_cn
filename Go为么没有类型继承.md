# Go为么没有类型继承？

面向对象编程，是最出名的语言模式，而它一直伴随一个话题：不同类型之间的关系定义。Go走了条不同的道路。

Go不采用要求程序员提前声明好两个类型是有关联的的方式，而是只要你的类型实现了一个接口（interface）的方法子集，那么这两个类型便有了关联。这个方式，不仅降低了程序底层记录各个类型的关系，而且有着其他显著优点：一个类型可以满足多个interface，而不用像传统的多重继承那么复杂。interface能够十分轻量（一个接口只有一个设置没有方法，也能表达出它的含义）。interface能够在事后你突然有一个主意的时候、或者想要写一个test方法的时候随意添加。因为类型之间并没有显式关系，不需要考虑类型继承的问题。(PS: 所以我觉得go确实是面向接口编程，gomock的实现也有这个关系：只能mock接口)

利用这个特性，我们实现了类型安全的（type-safe）类似Unix管道的东西。例如，`fmt.Fprintf`能够格式化所有类型的输出，而不是仅仅文件file类型；还有`bufio`包能够完全的从文件I/O中分离出来；还有`image`包生成压缩图片文件。以上实现方法都源于一个接口`io.write` ，特别是其中的`write`方法。这些都是冰山一角，Go的interface对程序的架构有着巨大影响。

这可能需要花点时间来适应，但是这种隐性的类型依赖是Go最有效率的体现之一。

```go
explicit 显式的，清晰的
after the fact 事后
 that's only scratching the surface 冰山一角
profound 深切的 巨大的 深远的
```


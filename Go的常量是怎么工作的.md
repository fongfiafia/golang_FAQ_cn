# Go的常量是怎么工作的?

虽然Go在不同数字类型的变量之间是严格的，但是常量反而更加灵活。诸如23,3.14159和Math.pi字面常数，占据了一定的空间，他们具有任意精度，没有溢出或下溢。例如，Math.pi的值指定为源代码中的63个位置，涉及该值的常量表达式将精确保持在float64可以容纳的位置。仅当常量或常量表达式被分配给程序中的变量时，它才会成为具有常用浮点属性和精度的“计算机”数值（computer number）。

此外，由于它们只是数字，而不是含有类型的值，因此可以比变量更自由地使用，从而软化一些严格的转换规则的尴尬。例如下面的表达式：

```go
sqrt2 := math.Sqrt(2)
```

这样是能通过编译的，因为number 2 能够在sqrt()方法中，安全并且精确的转化为float64。

PS：其实就是说数字类型的变量不能随心随意的转换，比如变量的转换：

```go
var a int64
var b int8
a = (int8) b
```

但是常量就不用了，上述例子中的 math.Sqrt()，参数其实是float64，然而我们可以直接传入常量2，而不需要做什么类型转换。
# Go的map操作为什么不定义为原子操作?

经过漫长的讨论，我们决定maps平常的使用不需要保证多协程的并发安全。而当需要考虑多协程并发安全的时候，往往map是一个更大的数据结构或者计算过程的一部分，这这些早就被同步锁住了。因此如果要求所有的map操作都先获取一个互斥锁反而会降低大部分程序运行速度，而换来一丁点儿的安全提升。这其实不是一个简单的决定，因为它意味着不受控制的map设计可能会导致程序崩溃。

Go后续版本不会排除原子实现map。当需要的时候，比如运行一个不信任的代码的时候，一些方法可以实现map的访问互锁（PS:不是很懂 the implementation could interlock map access）。

map的不安全只有在进行map更新的时候会发生。只要所有的协程都是在读取一个map，或者用for-range遍历map的时候，不要去分配或者删除map的元素，那么map的并发操作就算不上同步锁也是安全的。

为了帮助用户发现map的错误使用，Go语言实现了一些方法会提醒用户在更新map的时候可能存在并发安全的问题。

```go
preclude v 排除，阻止，妨碍
aid n 协助
```





